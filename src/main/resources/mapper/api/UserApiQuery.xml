<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd">

<mapper namespace="com.ict.quiz.api.user.UserApiMapper">

    <select id="checkDup" resultType="int">
        select count(*)
        from "user"
        where login_id = #{login_id}
    </select>

    <insert id="insertUser" parameterType="User" useGeneratedKeys="true" keyProperty="id">
        insert into "user" (
            login_id, password, name
        )
        values (
                #{login_id}
               , #{password}
               , #{name}
               )
    </insert>

    <select id="findHisList" resultType="UserQuestionHisResDto">
        select t1.id, t1.user_id, t1.seq, t1.category_id, t2.name as category_nm
             , t1.question_set
             , t1.progress_set
             , t1.answer_set
             , NULL as correct_set
             , t1.start_dt, t1.end_dt, t1.success_cd
             , length(t1.question_set) - length(replace(t1.question_set, ',', '')) + 1 as question_cnt
             , length(t1.correct_set) - length(replace(t1.correct_set, '1', '')) as correct_cnt
             , t2.logo_url
             , t1.accum_sec
             , t2.time_limit
          from user_question t1
               inner join category t2
                       on t2.id = t1.category_id
        where t1.user_id = #{user_id}
        order by t1.seq desc
        limit 20
    </select>

    <select id="findHisDetail" resultType="HisDetailDto">
        select t1.id
             , t1.question_set
             , t1.answer_set
             , t1.correct_set
             , t1.category_id
             , t2.name as category_nm
             , t1.success_cd
--              , if(t1.success_cd = 'S', '합격', '불합격') as success_cd_nm
             , case when t1.success_cd = 'S' then '합격' else '불합격' end as success_cd_nm
             , t2.success_percent as success_per
             , length(t1.question_set) - length(replace(t1.question_set, ',', '')) + 1 as total_q_cnt
             , length(t1.correct_set) - length(replace(t1.correct_set, '1', '')) as correct_cnt
             , length(t1.correct_set) - length(replace(t1.correct_set, '0', '')) as wrong_cnt
             , round((length(t1.correct_set) - length(replace(t1.correct_set, '1', '')))::numeric
                         / (length(t1.question_set) - length(replace(t1.question_set, ',', '')) + 1)
            * 100) as correct_per
             , t1.start_dt
             , t1.end_dt
             , t1.accum_sec
             , t2.time_limit
        from user_question t1
                 inner join category t2
                            on t1.category_id = t2.id
        where t1.id = #{id}
    </select>

    <select id="findUser" resultType="User">
        select id, login_id, password, name, admin_yn
          from "user"
         where login_id = #{login_id}
    </select>

    <select id="findCategoryHis" resultType="CategoryStatsCategoryResDto">
        select tb.id, tb.name, tb.logo_url, ta.attempt_count
        from (
                 select category_id, max(id) as max_category_id, count(id) as attempt_count
                 from user_question
                 where user_id = #{user_id}
                 group by category_id
             ) ta
                 inner join category tb
                            on tb.id = ta.category_id
        order by ta.max_category_id desc
    </select>

    <select id="findCategoryStats" resultType="CategoryStatsResDto">
        select select_count
             , count(question_id) as attempt_count
             , round(avg(correct_rate), 2) as correct_rate
        from (
                 SELECT
                     q.id   AS question_id,
                     COALESCE(COUNT(*) FILTER (WHERE q.id = q_ids.elem::bigint), 0) AS select_count,
                     CASE
                         WHEN COALESCE(COUNT(*) FILTER (WHERE q.id = q_ids.elem::bigint), 0) > 0 THEN
                             ROUND(
                                     (COALESCE(COUNT(*) FILTER (WHERE q.id = q_ids.elem::bigint AND corr.elem = '1'), 0)::numeric
                            * 100.0)
                                         / COALESCE(COUNT(*) FILTER (WHERE q.id = q_ids.elem::bigint), 0), 2
                             )
                         ELSE 0
                         END AS correct_rate
                 FROM question q
                          LEFT JOIN user_question uq
                                    ON uq.category_id = q.category_id
                                        and uq.success_cd is not null
                                        and uq.user_id = #{user_id}
                          LEFT JOIN LATERAL unnest(string_to_array(uq.question_set, ',')) WITH ORDINALITY AS q_ids(elem, idx)
                 ON TRUE
                     LEFT JOIN LATERAL unnest(string_to_array(uq.correct_set, ',')) WITH ORDINALITY AS corr(elem, idx2)
                 ON corr.idx2 = q_ids.idx
                 WHERE q.category_id = #{category_id}
                 GROUP BY q.id, q.text
             )
        group by select_count
        order by select_count
    </select>


</mapper>